BANCO DE DADOS 1 - TRABALHO 3 - TAREFA 13
============================================================

CENÁRIO: Consulta A - Usando MAX
QUERY: SELECT title FROM movie WHERE votes >= (SELECT MAX(votes) FROM movie);
------------------------------
                                            Index Scan using movie_votes on movie  (cost=0.61..35.37 rows=615 width=16) (actual time=0.009..0.010 rows=1 loops=1)
                                                                                                                                        Index Cond: (votes >= $1)
                                                                                                                                          InitPlan 2 (returns $1)
                                                                           ->  Result  (cost=0.32..0.33 rows=1 width=4) (actual time=0.005..0.006 rows=1 loops=1)
                                                                                                                                          InitPlan 1 (returns $0)
                                                                            ->  Limit  (cost=0.28..0.32 rows=1 width=4) (actual time=0.004..0.004 rows=1 loops=1)
                  ->  Index Only Scan Backward using movie_votes on movie movie_1  (cost=0.28..76.55 rows=1844 width=4) (actual time=0.004..0.004 rows=1 loops=1)
                                                                                                                                  Index Cond: (votes IS NOT NULL)
                                                                                                                                                  Heap Fetches: 0
                                                                                                                                          Planning Time: 0.039 ms
                                                                                                                                         Execution Time: 0.016 ms

============================================================

CENÁRIO: Consulta B - Usando ALL
QUERY: SELECT title FROM movie WHERE votes >= ALL (SELECT votes FROM movie);
------------------------------
                      Seq Scan on movie  (cost=0.00..43620.99 rows=922 width=16) (actual time=0.526..0.832 rows=1 loops=1)
                                                                                                       Filter: (SubPlan 1)
                                                                                              Rows Removed by Filter: 1843
                                                                                                                 SubPlan 1
                        ->  Materialize  (cost=0.00..42.66 rows=1844 width=4) (actual time=0.000..0.000 rows=2 loops=1844)
          ->  Seq Scan on movie movie_1  (cost=0.00..33.44 rows=1844 width=4) (actual time=0.002..0.174 rows=1844 loops=1)
                                                                                                   Planning Time: 0.057 ms
                                                                                                  Execution Time: 0.856 ms

============================================================

ANÁLISE E RESPOSTAS:
------------------------------

RESPOSTA DA QUESTÃO 13 (Análise Comparativa):

a) Diferença entre os planos:
   SIM, houve uma diferença.
   - A Consulta A (MAX) utilizou um 'InitPlan' com 'Index Only Scan'. O banco calculou
     o valor máximo uma única vez (acessando o índice de forma invertida) e usou esse
     valor para filtrar a tabela.
   - A Consulta B (ALL) falhou em otimizar a lógica. O plano mostra um 'Seq Scan'
     (varredura sequencial) combinado com um 'SubPlan' que foi executado repetidamente
     (loops=1844), gerando um produto cartesiano lógico.

b) Qual das duas é mais eficiente?
   A Consulta A (MAX) é muito mais eficiente.
   - Custo estimado: ~35.37 (MAX) vs ~43620.99 (ALL).
   - Tempo real: 0.063ms (MAX) vs 0.632ms (ALL).

c) Explicação:
   Embora as consultas pareçam equivalentes, o operador 'ALL' possui uma semântica
   complexa de tratamento de valores NULL (se houver um NULL na subconsulta, o resultado
   pode ser indeterminado). O otimizador do PostgreSQL, neste cenário, não conseguiu
   garantir que a transformação de 'ALL' para 'MAX' seria segura ou vantajosa, apesar de
   não haver NULLs no DB (apenas ). Ele deicidiu optar por um plano genérico de verificação
   linha-a-linha (nested loop/materialize), o que elevou drasticamente o custo computacional.
